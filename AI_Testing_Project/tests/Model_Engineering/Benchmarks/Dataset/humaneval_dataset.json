{"task_id": "HumanEval/0", "prompt": "def has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\"\n", "completion": "", "test": "def check(candidate):\n    assert candidate([1.0, 2.0, 3.0], 0.5) == False\n    assert candidate([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3) == True\n    assert candidate([1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.3) == True\n    assert candidate([1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.05) == False\n    assert candidate([1.0, 2.0, 5.9, 4.0, 5.0], 0.95) == True\n    assert candidate([1.0, 2.0, 5.9, 4.0, 5.0], 0.8) == False\n    assert candidate([1.0, 2.0, 3.0, 4.0, 5.0, 2.0], 0.1) == True\n    assert candidate([1.1, 2.2, 3.1, 4.1, 5.1], 1.0) == True\n    assert candidate([1.1, 2.2, 3.1, 4.1, 5.1], 0.5) == False\n\n\ncheck(has_close_elements)", "description": "Check if in the given list of numbers, any two numbers are closer to each other than the given threshold."}
{"task_id": "HumanEval/1", "prompt": "def separate_paren_groups(paren_string: str) -> List[str]:\n    \"\"\" Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n    separate those group into separate strings and return the list of those.\n    Separate groups are balanced (each open brace is properly closed) and not nested within each other\n    Ignore any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) (( )( ))')\n    ['()', '(())', '(()())']    \n    \"\"\"\n", "completion": "", "test": "def check(candidate):\n    assert candidate('(()()) ((())) () ((())()())') == ['(()())', '((()))', '()', '((())()())']\n    assert candidate('() (()) ((())) (((())))') == ['()', '(())', '((()))', '(((())))']\n    assert candidate('(()(())((())))') == ['(()(())((())))']\n    assert candidate('( ) (( )) (( )( ))') == ['()', '(())', '(()())']\n\n\ncheck(separate_paren_groups)", "description": "Separate nested parentheses groups into a list of strings, where each group is balanced and not nested within others."}
{"task_id": "HumanEval/2", "prompt": "def truncate_number(number: float) -> float:\n    \"\"\" Given a positive floating point number, it can be decomposed into\n    and integer part (largest integer smaller than given number) and decimals\n    (leftover part always smaller than 1).\n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"\n", "completion": "", "test": "def check(candidate):\n    assert candidate(3.5) == 0.5\n    assert abs(candidate(1.33) - 0.33) < 1e-6\n    assert abs(candidate(123.456) - 0.456) < 1e-6\n\n\ncheck(truncate_number)", "description": "Extract and return the decimal part of a positive floating point number."}
{"task_id": "HumanEval/3", "prompt": "def below_zero(operations: List[int]) -> bool:\n    \"\"\" You're given a list of integer numbers called operations. The list has an even \n    length and each two consecutive elements represent deposits and withdrawals.\n    Determine if after all operations the balance ever goes below zero.\n    >>> below_zero([1, -1, 2, -2, 5, -5, 4, -4])\n    False\n    >>> below_zero([1, -2, 2, -2, 5, -5, 4, -4])\n    True\n    >>> below_zero([1, -1])\n    False\n    \"\"\"\n", "completion": "", "test": "def check(candidate):\n    assert candidate([1, -1, 2, -2, 5, -5, 4, -4]) == False\n    assert candidate([1, -2, 2, -2, 5, -5, 4, -4]) == True\n    assert candidate([1, -1]) == False\n    assert candidate([1, -1, 1, -1]) == False\n    assert candidate([1, -2, 2, -1]) == True\n    assert candidate([1, -2]) == True\n    assert candidate([1, -1, 1, -1, 1, -1, 1, -1]) == False\n    assert candidate([1, -1, 1, -1, 1, -1, 1, -1, 1, -1]) == False\n\n\ncheck(below_zero)", "description": "Check if after performing a series of deposit and withdrawal operations, the balance ever goes below zero."}
{"task_id": "HumanEval/4", "prompt": "def mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\" For a given list of input numbers, calculate Mean Absolute Deviation\n    around the mean of this dataset.\n    Mean Absolute Deviation is the average absolute difference between each\n    element and a centerpoint (mean in this case):\n    MAD = average | x - x_mean |\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    \"\"\"\n", "completion": "", "test": "def check(candidate):\n    assert abs(candidate([1.0, 2.0, 3.0, 4.0]) - 1.0) < 1e-6\n    assert abs(candidate([1.0, 2.0, 3.0, 4.0, 5.0]) - 1.2) < 1e-6\n    assert abs(candidate([2.0, 2.0, 2.0, 2.0, 2.0]) - 0.0) < 1e-6\n    assert abs(candidate([1.0, 2.0, 3.0]) - 0.6666666666666666) < 1e-6\n    assert abs(candidate([1.0, 2.0, 3.0, 4.0, 5.0, 6.0]) - 1.5) < 1e-6\n\n\ncheck(mean_absolute_deviation)", "description": "Calculate the Mean Absolute Deviation (MAD) for a given list of numbers, which measures the average absolute difference between each number and the mean."}
{"task_id": "HumanEval/5", "prompt": "def intersperse(numbers: List[int], delimiter: int) -> List[int]:\n    \"\"\" Insert a number 'delimiter' between every two consecutive elements of input list `numbers'\n    >>> intersperse([], 4)\n    []\n    >>> intersperse([1, 2, 3], 4)\n    [1, 4, 2, 4, 3]\n    \"\"\"\n", "completion": "", "test": "def check(candidate):\n    assert candidate([], 4) == []\n    assert candidate([1, 2, 3], 4) == [1, 4, 2, 4, 3]\n    assert candidate([1], 4) == [1]\n    assert candidate([1, 2], 4) == [1, 4, 2]\n    assert candidate([1, 2, 3, 4, 5], 4) == [1, 4, 2, 4, 3, 4, 4, 4, 5]\n\n\ncheck(intersperse)", "description": "Insert a delimiter number between every two consecutive elements of the input list."}
{"task_id": "HumanEval/6", "prompt": "def parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n", "completion": "", "test": "def check(candidate):\n    assert candidate('(()()) ((())) () ((())()())') == [2, 3, 1, 3]\n    assert candidate('() (()) ((())) (((())))') == [1, 2, 3, 4]\n    assert candidate('(()(())((())))') == [4]\n    assert candidate('( ) (( )) (( )( ))') == [1, 2, 2]\n\n\ncheck(parse_nested_parens)", "description": "Calculate the maximum nesting depth of parentheses for each group in the input string."}
{"task_id": "HumanEval/7", "prompt": "def filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\" Filter an input list of strings only for ones that contain given substring\n    >>> filter_by_substring([], 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']\n    \"\"\"\n", "completion": "", "test": "def check(candidate):\n    assert candidate([], 'john') == []\n    assert candidate(['xxx', 'asd', 'xxy', 'john doe', 'xxxAAA', 'xxx'], 'xxx') == ['xxx', 'xxxAAA', 'xxx']\n    assert candidate(['xxx', 'asd', 'aaaxxy', 'john doe', 'xxxAAA', 'xxx'], 'xx') == ['xxx', 'aaaxxy', 'xxxAAA', 'xxx']\n    assert candidate(['grunt', 'trumpet', 'prune', 'gruesome'], 'run') == ['grunt', 'prune']\n\n\ncheck(filter_by_substring)", "description": "Filter a list of strings to only include those that contain the given substring."}
{"task_id": "HumanEval/8", "prompt": "def sum_product(numbers: List[int]) -> Tuple[int, int]:\n    \"\"\" For a given list of integers, return a tuple consisting of a sum and a product of all the integers in a list.\n    Empty sum should be equal to 0 and empty product should be equal to 1.\n    >>> sum_product([])\n    (0, 1)\n    >>> sum_product([1, 2, 3, 4])\n    (10, 24)\n    \"\"\"\n", "completion": "", "test": "def check(candidate):\n    assert candidate([]) == (0, 1)\n    assert candidate([1, 1, 1]) == (3, 1)\n    assert candidate([100, 0]) == (100, 0)\n    assert candidate([3, 5, 7]) == (15, 105)\n    assert candidate([10]) == (10, 10)\n    assert candidate([1, 2, 3, 4]) == (10, 24)\n\n\ncheck(sum_product)", "description": "Calculate both the sum and product of all integers in the input list, returning them as a tuple."}
{"task_id": "HumanEval/9", "prompt": "def rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\"\n", "completion": "", "test": "def check(candidate):\n    assert candidate([]) == []\n    assert candidate([1, 2, 3, 4]) == [1, 2, 3, 4]\n    assert candidate([4, 3, 2, 1]) == [4, 4, 4, 4]\n    assert candidate([3, 2, 3, 100, 3]) == [3, 3, 3, 100, 100]\n    assert candidate([1, 2, 3, 2, 3, 4, 2]) == [1, 2, 3, 3, 3, 4, 4]\n\n\ncheck(rolling_max)", "description": "Generate a list where each element is the maximum value encountered up to that position in the input sequence."}
{"task_id": "HumanEval/10", "prompt": "def make_palindrome(string: str) -> str:\n    \"\"\" Find the shortest palindrome that begins with a supplied string.\n    Algorithm idea is simple:\n    - Find the longest postfix of supplied string that is a palindrome.\n    - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    >>> make_palindrome('')\n    ''\n    >>> make_palindrome('cat')\n    'catac'\n    >>> make_palindrome('cata')\n    'catac'\n    \"\"\"\n", "completion": "", "test": "def check(candidate):\n    assert candidate('') == ''\n    assert candidate('x') == 'x'\n    assert candidate('xyz') == 'xyzyx'\n    assert candidate('xyx') == 'xyx'\n    assert candidate('jerry') == 'jerryrrej'\n    assert candidate('cat') == 'catac'\n    assert candidate('cata') == 'catac'\n    assert candidate('radar') == 'radar'\n\n\ncheck(make_palindrome)", "description": "Create the shortest palindrome by appending characters to the end of the input string, ensuring it begins with the input string."}
